package cryptography.lattice.ring_lwe.category

import cryptography.lattice.ring_lwe.matrix.LowerTriangularOneMatrix
import math.abstract_structure.instance.FieldComplexNumberDouble
import math.abstract_structure.instance.FieldDouble
import math.abstract_structure.module.category.ModuleCategories
import math.abstract_structure.module.freeModule
import math.integer.uint.RingUInt
import math.integer.uint.factored.UIntPPI
import math.integer.uint.modular.FieldModularUInt
import math.integer.uint.modular.RingModularUInt
import math.martix.whiskered

/**
 * Created by CowardlyLion at 2022/1/26 13:36
 *
 * require [q] be prime
 */
class CategoryInCyclotomicField(val order: UIntPPI, val q: FieldModularUInt) {


    val dimension = order.eulerTotient


    fun modularZModule(modulus: UInt) = ModuleCategories.categoryOf(RingModularUInt(modulus))

    val integerModuloQModule = ModuleCategories.categoryOf(q)

    /**
     * ℚ(ζp^i) ⊗ ℂ
     */
    val extendedCyclotomicFieldPowerBasis = FieldComplexNumberDouble.freeModule("${order.value}-th cyclotomic field with power basis", dimension)

    val standardBasis = FieldComplexNumberDouble.freeModule("standard basis", dimension)


    /**
     * ℚ(ζp^i) ⊗ ℝ
     */
    val cyclotomicFieldPowerBasis = FieldDouble.freeModule("${order.value}-th cyclotomic field with power basis", dimension)


    /**
     * ℤ(ζp^i)
     */
    val ringOfIntegerPowerBasis = RingUInt.freeModule("ring of integer of ℚ(ζp^i) with power basis", dimension)

    /**
     * dual(ℤ(ζp^i))
     */
    val dualRingOfIntegerPowerBasis = RingUInt.freeModule("dual lattice of ℤ(ζp^i) with basis generated by (1-ζp)/p^i multiply with power basis of ℤ(ζp^i)", dimension)
    val dualRingOfIntegerDecodingBasis = RingUInt.freeModule("dual lattice of ℤ(ζp^i) with dual basis of conjugate power basis of ℤ(ζp^i)", dimension)


    /**
     * ℤ(ζp^i) / q * ℤ(ζp^i)
     */
    val ringOfIntegerModuloQPowerBasis = q.freeModule("ℤ(ζp^i) modulo ${q.prime} with power basis", dimension)
    val ringOfIntegerModuloQChineseRemainderBasis = q.freeModule("ℤ(ζp^i) modulo ${q.prime} with chinese remainder basis", dimension)


    /**
     * dual(ℤ(ζp^i)) / q * dual(ℤ(ζp^i))
     */
    val dualRingOfIntegerModuloQPowerBasis = q.freeModule("dual(ℤ(ζp^i)) modulo ${q.prime} with basis generated by (1-ζp)/p^i multiply with power basis of ℤ(ζp^i)", dimension)
    val dualRingOfIntegerModuloQDecodingBasis = q.freeModule("dual(ℤ(ζp^i)) modulo ${q.prime} with dual basis of conjugate power basis of ℤ(ζp^i)", dimension)
    val dualRingOfIntegerModuloQChineseRemainderBasis = q.freeModule("dual(ℤ(ζp^i)) modulo ${q.prime} with chinese remainder basis", dimension)


    init {
        complexModule.registerBase(extendedCyclotomicFieldPowerBasis)
        complexModule.registerBase(standardBasis)

        val root = FieldComplexNumberDouble.root(order)
//        complexModule.registerArrow(extendedCyclotomicFieldPowerBasis, standardBasis, ChineseRemainderTransformMatrixPrimePower(root, ChineseRemainderTransformMatrixPrime(root.primeSubroot())))
    }

    init {
        realModule.registerBase(cyclotomicFieldPowerBasis)
    }


    init {
        integerModule.registerBase(ringOfIntegerPowerBasis)

        integerModule.registerBase(dualRingOfIntegerPowerBasis)
        integerModule.registerBase(dualRingOfIntegerDecodingBasis)

        val decodingToPower = if (order.power == 1u) {
            LowerTriangularOneMatrix(RingUInt, order.prime - 1u)
        } else {
            RingUInt.whiskered(dimension, 1u, LowerTriangularOneMatrix(RingUInt, order.prime - 1u), order.value / order.prime)
        }
        integerModule.registerArrow(dualRingOfIntegerDecodingBasis, dualRingOfIntegerPowerBasis, decodingToPower)
    }

    init {
        integerModuloQModule.registerBase(ringOfIntegerModuloQPowerBasis)
        integerModuloQModule.registerBase(ringOfIntegerModuloQChineseRemainderBasis)

//        val root = q.firstGenerator.subrootUnsafe(order)
//        val crt = ChineseRemainderTransformMatrixPrimePower(root, ChineseRemainderTransformMatrixPrime(root.primeSubroot()))
//        integerModuloQModule.registerArrow(ringOfIntegerModuloQPowerBasis, ringOfIntegerModuloQChineseRemainderBasis, crt)

        integerModuloQModule.registerBase(dualRingOfIntegerModuloQPowerBasis)
        integerModuloQModule.registerBase(dualRingOfIntegerModuloQDecodingBasis)
        integerModuloQModule.registerBase(dualRingOfIntegerModuloQChineseRemainderBasis)

//        integerModuloQModule.registerArrow(dualRingOfIntegerModuloQPowerBasis, dualRingOfIntegerModuloQChineseRemainderBasis, crt)
        val decodingToPower = if (order.power == 1u) {
            LowerTriangularOneMatrix(q, order.prime - 1u)
        } else {
            q.whiskered(dimension, 1u, LowerTriangularOneMatrix(q, order.prime - 1u), order.value / order.prime)
        }
        integerModuloQModule.registerArrow(dualRingOfIntegerModuloQDecodingBasis, dualRingOfIntegerModuloQPowerBasis, decodingToPower)

    }

}