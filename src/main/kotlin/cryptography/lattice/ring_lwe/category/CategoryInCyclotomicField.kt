package cryptography.lattice.ring_lwe.category

import cryptography.lattice.ring_lwe.matrix.ChineseRemainderTransformMatrixPrime
import cryptography.lattice.ring_lwe.matrix.ChineseRemainderTransformMatrixPrimePower
import cryptography.lattice.ring_lwe.matrix.LowerTriangularOneMatrix
import math.abstract_structure.instance.*
import math.abstract_structure.module.category.CategoryOfModule
import math.abstract_structure.module.freeModule
import math.integer.FactorizationUIntPrimePower
import math.martix.whiskered

/**
 * Created by CowardlyLion at 2022/1/26 13:36
 *
 * require [q] be prime
 */
class CategoryInCyclotomicField(val order: FactorizationUIntPrimePower, val q: FieldModularUInt) {


    val phiOrder = order.eulerTotient

    val categoies = CategoryOfModule()

    val complexModule = categoies.categoryOf(FieldComplexNumberDouble)
    val realModule = categoies.categoryOf(FieldDouble)
    val integerModule = categoies.categoryOf(RingUInt)
    fun modularZModule(modulus: UInt) = categoies.categoryOf(RingModularUInt(modulus))

    val integerModuloQModule = categoies.categoryOf(q)

    /**
     * ℚ(ζp^i) ⊗ ℂ
     */
    val extendedCyclotomicFieldPowerBasis = FieldComplexNumberDouble.freeModule("${order.value}-th cyclotomic field with power basis", phiOrder)

    val standardBasis = FieldComplexNumberDouble.freeModule("standard basis", phiOrder)


    /**
     * ℚ(ζp^i) ⊗ ℝ
     */
    val cyclotomicFieldPowerBasis = FieldDouble.freeModule("${order.value}-th cyclotomic field with power basis", phiOrder)


    /**
     * ℤ(ζp^i)
     */
    val ringOfIntegerPowerBasis = RingUInt.freeModule("ring of integer of ℚ(ζp^i) with power basis", phiOrder)

    /**
     * dual(ℤ(ζp^i))
     */
    val dualRingOfIntegerPowerBasis = RingUInt.freeModule("dual lattice of ℤ(ζp^i) with basis generated by (1-ζp)/p^i multiply with power basis of ℤ(ζp^i)", phiOrder)
    val dualRingOfIntegerDecodingBasis = RingUInt.freeModule("dual lattice of ℤ(ζp^i) with dual basis of conjugate power basis of ℤ(ζp^i)", phiOrder)


    /**
     * ℤ(ζp^i) / q * ℤ(ζp^i)
     */
    val ringOfIntegerModuloQPowerBasis = q.freeModule("ℤ(ζp^i) modulo ${q.prime} with power basis", phiOrder)
    val ringOfIntegerModuloQChineseRemainderBasis = q.freeModule("ℤ(ζp^i) modulo ${q.prime} with chinese remainder basis", phiOrder)


    /**
     * dual(ℤ(ζp^i)) / q * dual(ℤ(ζp^i))
     */
    val dualRingOfIntegerModuloQPowerBasis = q.freeModule("dual(ℤ(ζp^i)) modulo ${q.prime} with basis generated by (1-ζp)/p^i multiply with power basis of ℤ(ζp^i)", phiOrder)
    val dualRingOfIntegerModuloQDecodingBasis = q.freeModule("dual(ℤ(ζp^i)) modulo ${q.prime} with dual basis of conjugate power basis of ℤ(ζp^i)", phiOrder)
    val dualRingOfIntegerModuloQChineseRemainderBasis = q.freeModule("dual(ℤ(ζp^i)) modulo ${q.prime} with chinese remainder basis", phiOrder)


    init {
        complexModule.registerBase(extendedCyclotomicFieldPowerBasis)
        complexModule.registerBase(standardBasis)

        val root = FieldComplexNumberDouble.root(order)
        complexModule.registerArrow(extendedCyclotomicFieldPowerBasis, standardBasis, ChineseRemainderTransformMatrixPrimePower(root, ChineseRemainderTransformMatrixPrime(root.primeSubroot())))
    }

    init {
        realModule.registerBase(cyclotomicFieldPowerBasis)
    }


    init {
        integerModule.registerBase(ringOfIntegerPowerBasis)

        integerModule.registerBase(dualRingOfIntegerPowerBasis)
        integerModule.registerBase(dualRingOfIntegerDecodingBasis)

        val decodingToPower = if (order.power == 1u) {
            LowerTriangularOneMatrix(RingUInt, order.prime - 1u)
        } else {
            RingUInt.whiskered(1u, LowerTriangularOneMatrix(RingUInt, order.prime - 1u), order.value / order.prime)
        }
        integerModule.registerArrow(dualRingOfIntegerDecodingBasis, dualRingOfIntegerPowerBasis, decodingToPower)
    }

    init {
        integerModuloQModule.registerBase(ringOfIntegerModuloQPowerBasis)
        integerModuloQModule.registerBase(ringOfIntegerModuloQChineseRemainderBasis)

        val root = q.firstGenerator.subroot(order)
        val crt = ChineseRemainderTransformMatrixPrimePower(root, ChineseRemainderTransformMatrixPrime(root.primeSubroot()))
        integerModuloQModule.registerArrow(ringOfIntegerModuloQPowerBasis, ringOfIntegerModuloQChineseRemainderBasis, crt)

        integerModuloQModule.registerBase(dualRingOfIntegerModuloQPowerBasis)
        integerModuloQModule.registerBase(dualRingOfIntegerModuloQDecodingBasis)
        integerModuloQModule.registerBase(dualRingOfIntegerModuloQChineseRemainderBasis)

        integerModuloQModule.registerArrow(dualRingOfIntegerModuloQPowerBasis, dualRingOfIntegerModuloQChineseRemainderBasis, crt)
        val decodingToPower = if (order.power == 1u) {
            LowerTriangularOneMatrix(q, order.prime - 1u)
        } else {
            q.whiskered(1u, LowerTriangularOneMatrix(q, order.prime - 1u), order.value / order.prime)
        }
        integerModuloQModule.registerArrow(dualRingOfIntegerModuloQDecodingBasis, dualRingOfIntegerModuloQPowerBasis, decodingToPower)

    }

}